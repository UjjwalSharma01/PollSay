-- Create auxiliary function to check if a user is an admin of an organization
-- This avoids infinite recursion in policies
CREATE OR REPLACE FUNCTION is_admin_of_org(p_user_id UUID, p_org_id UUID) 
RETURNS BOOLEAN AS $$
BEGIN
  -- We use SECURITY DEFINER to avoid policy recursion
  RETURN EXISTS (
    SELECT 1 
    FROM public.team_members
    WHERE user_id = p_user_id
      AND org_id = p_org_id
      AND role = 'admin'
      AND status = 'active'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create function to check if a user is a member of an organization
CREATE OR REPLACE FUNCTION is_member_of_org(p_user_id UUID, p_org_id UUID) 
RETURNS BOOLEAN AS $$
BEGIN
  -- We use SECURITY DEFINER to avoid policy recursion
  RETURN EXISTS (
    SELECT 1 
    FROM public.team_members
    WHERE user_id = p_user_id
      AND org_id = p_org_id
      AND status = 'active'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- First, make sure we drop all existing team_member policies
DO $$
BEGIN
  -- Drop all policies from team_members table
  DROP POLICY IF EXISTS "TeamMembers Update Access for Self or Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Select Own and Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Update Own or Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Update Access for Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Insert by Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Delete by Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Select Access for Members" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Insert Access for Admins" ON public.team_members;
  DROP POLICY IF EXISTS "TeamMembers Delete Access for Admins" ON public.team_members;
  DROP POLICY IF EXISTS "tm_select_policy" ON public.team_members;
  DROP POLICY IF EXISTS "tm_update_policy" ON public.team_members;
  DROP POLICY IF EXISTS "tm_insert_policy" ON public.team_members;
  DROP POLICY IF EXISTS "tm_delete_policy" ON public.team_members;
END;
$$;

-- Create non-recursive version of team_members policies
-- Policy for SELECT: Users can see themselves and admins can see members of their org
CREATE POLICY "tm_select_self" ON public.team_members
  FOR SELECT USING (user_id = auth.uid());
  
CREATE POLICY "tm_select_as_admin" ON public.team_members 
  FOR SELECT USING (is_admin_of_org(auth.uid(), org_id));

-- Policy for UPDATE: Users can update themselves
CREATE POLICY "tm_update_self" ON public.team_members
  FOR UPDATE USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());
  
-- Policy for UPDATE: Admins can update members of their org
CREATE POLICY "tm_update_as_admin" ON public.team_members
  FOR UPDATE USING (is_admin_of_org(auth.uid(), org_id))
  WITH CHECK (is_admin_of_org(auth.uid(), org_id));

-- Policy for INSERT: Only admins can add new members to their org
CREATE POLICY "tm_insert_as_admin" ON public.team_members
  FOR INSERT WITH CHECK (is_admin_of_org(auth.uid(), org_id));

-- Policy for DELETE: Only admins can delete members from their org
CREATE POLICY "tm_delete_as_admin" ON public.team_members
  FOR DELETE USING (is_admin_of_org(auth.uid(), org_id));

-- Create a special policy for first user in an organization (bootstrap admin)
CREATE OR REPLACE FUNCTION is_first_user_in_org(p_user_id UUID, p_org_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  -- Check if this would be the first user in this org
  RETURN NOT EXISTS (
    SELECT 1 
    FROM public.team_members
    WHERE org_id = p_org_id
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Allow inserting the first user (usually admin) into a new org
CREATE POLICY "tm_insert_first_user" ON public.team_members
  FOR INSERT WITH CHECK (
    is_first_user_in_org(auth.uid(), org_id)
    AND user_id = auth.uid()
    AND role = 'admin'
  );

-- Fix the ambiguous column references in set_default_org_for_form function
CREATE OR REPLACE FUNCTION set_default_org_for_form()
RETURNS TRIGGER AS $$
DECLARE
  v_auth_id uuid;
BEGIN
  -- Get current user ID explicitly
  v_auth_id := auth.uid();
  
  -- Set the created_by field if not already set
  IF NEW.created_by IS NULL THEN
    NEW.created_by := v_auth_id;
  END IF;
  
  -- If org_id is not provided, try to get user's primary organization
  IF NEW.org_id IS NULL THEN
    -- Try to find a default/primary organization for the user
    SELECT tm.org_id INTO NEW.org_id
    FROM public.team_members AS tm
    WHERE tm.user_id = v_auth_id
    AND tm.status = 'active'
    ORDER BY tm.created_at ASC
    LIMIT 1;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Fix Forms Insert Access policy to use the helper function
DROP POLICY IF EXISTS "Forms Insert Access" ON public.forms;
CREATE POLICY "Forms Insert Access" ON public.forms 
FOR INSERT WITH CHECK (
  auth.uid() = created_by 
  AND (
    org_id IS NULL
    OR is_member_of_org(auth.uid(), org_id)
  )
);



-- adding new queries to make the form public or not so that it's easy to fetch

-- Add is_public column to forms table if it doesn't exist
ALTER TABLE public.forms ADD COLUMN IF NOT EXISTS is_public BOOLEAN DEFAULT false;

-- Make sure to enable RLS on forms table if not already enabled
ALTER TABLE public.forms ENABLE ROW LEVEL SECURITY;

-- Improve form SELECT policies to handle all access scenarios
DROP POLICY IF EXISTS "Forms Select Own" ON public.forms;
DROP POLICY IF EXISTS "Forms Select Org Member" ON public.forms;
DROP POLICY IF EXISTS "Forms Select Public" ON public.forms;
DROP POLICY IF EXISTS "Forms Select By Share Code" ON public.forms;

-- 1. Users can see forms they created
CREATE POLICY "Forms Select Own" ON public.forms
  FOR SELECT USING (auth.uid() = created_by);

-- 2. Users can see forms in organizations they're a member of
CREATE POLICY "Forms Select Org Member" ON public.forms
  FOR SELECT USING (
    org_id IS NOT NULL
    AND is_member_of_org(auth.uid(), org_id)
  );

-- 3. Anyone can see public forms (authenticated or not)
CREATE POLICY "Forms Select Public" ON public.forms
  FOR SELECT USING (is_public = true);

-- 4. Anyone can access a form via share_code (crucial for sharing!)
CREATE POLICY "Forms Select By Share Code" ON public.forms
  FOR SELECT USING (true);

-- Check and ensure other necessary form policies exist
-- For example, UPDATE and DELETE policies
DROP POLICY IF EXISTS "Forms Update Access" ON public.forms;
CREATE POLICY "Forms Update Access" ON public.forms
  FOR UPDATE USING (auth.uid() = created_by)
  WITH CHECK (auth.uid() = created_by);

DROP POLICY IF EXISTS "Forms Delete Access" ON public.forms;
CREATE POLICY "Forms Delete Access" ON public.forms
  FOR DELETE USING (auth.uid() = created_by);

-- Helper view for debugging policies
CREATE OR REPLACE VIEW user_permissions AS
SELECT 
  auth.uid() AS current_user_id,
  tm.org_id,
  tm.role,
  tm.status,
  o.org_name,
  is_admin_of_org(auth.uid(), tm.org_id) AS is_admin,
  is_member_of_org(auth.uid(), tm.org_id) AS is_member
FROM 
  public.team_members tm
  JOIN public.organizations o ON tm.org_id = o.id
WHERE 
  tm.user_id = auth.uid();
